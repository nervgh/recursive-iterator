/*!
 * recursive-iterator v3.3.0
 * https://github.com/nervgh/recursive-iterator
 */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.RecursiveIterator=e():t.RecursiveIterator=e()}(this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,e),i.l=!0,i.exports}var n={};return e.m=t,e.c=n,e.i=function(t){return t},e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:r})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=1)}([function(t,e,n){"use strict";function r(t){return null!==t&&"object"==typeof t}function i(t){if(!r(t))return!1;if(!("length"in t))return!1;const e=t.length;if(!o(e))return!1;if(e>0)return e-1 in t;for(const n in t)return!1}function o(t){return"number"==typeof t}function s(t){const e=Object.keys(t);if(isArray(t));else if(i(t)){const t=e.indexOf("length");t>-1&&e.splice(t,1)}else e.sort();return e}const{isArray:isArray}=Array;e.getKeys=s,e.isArray=isArray,e.isArrayLike=i,e.isObject=r,e.isNumber=o},function(t,e,n){"use strict";const{isObject:isObject,getKeys:getKeys}=n(0),r="__state",i={};class o{constructor(t,e=0,n=!1,i=100){this.__bypassMode=e,this.__ignoreCircular=n,this.__maxDeep=i,this.__cache=[],this.__queue=[],this[r]=this.getState(void 0,t)}next(){const{node:node,path:path,deep:deep}=this[r]||i;if(this.__maxDeep>deep&&this.isNode(node))if(this.isCircular(node)){if(!this.__ignoreCircular)throw new Error("Circular reference")}else if(this.onStepInto(this[r])){const t=this.getStatesOfChildNodes(node,path,deep),e=this.__bypassMode?"push":"unshift";this.__queue[e](...t),this.__cache.push(node)}const t=this.__queue.shift(),e=!t;return this[r]=t,e&&this.destroy(),{value:t,done:e}}destroy(){this.__queue.length=0,this.__cache.length=0,this[r]=null}isNode(t){return isObject(t)}isLeaf(t){return!this.isNode(t)}isCircular(t){return this.__cache.indexOf(t)!==-1}getStatesOfChildNodes(t,e,n){return getKeys(t).map(r=>this.getState(t,t[r],r,e.concat(r),n+1))}getState(t,e,n,r=[],i=0){return{parent:t,node:e,key:n,path:r,deep:i}}onStepInto(t){return!0}[Symbol.iterator](){return this}}t.exports=o}])});
//# sourceMappingURL=recursive-iterator.min.js.map